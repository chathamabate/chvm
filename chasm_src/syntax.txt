
:: SYNTAX NOTES FOR CHVM ASSEMBLY ::

:: Typing ::

There are 4 primitive types :
- int   A signed 64-bit integer.
- flt   A 64-bit floating point number.
- idx   A 32-bit unsigned integer. (Used for offsets into arrays)
- chr   A 8-bit character/byte.

All remaining types are built from these types.

An array or "arr" is a composite value containing a fixed length sequence of
identically typed values.

Examples :
arr<int, 5>             An array of 5 integers.
arr<arr<flt, 3>, 3>     A 3x3 matrix of floats.

A record or "rec" is a value composed of named values.
The types of these values can be heterogeneous.

Examples :

rec {
    int x;
    int y;
}

rec {
    arr<char, 6> id;

    rec {
        int x;
        int y;
    } coordinate;
}

From this point further, a piece of data managed by the garbage collector
will be known as "Dynamic" whereas a piece of data which resides on the 
call stack will be known as "Static". 

All dynamic pieces of data have identifiers known as "Virtual Addresses".
A "Virtual Address" is used to aquire the lock on a dynamic piece of 
data, and in turn, retrieve the temporary location of the data. 
i.e. the "Physical Address".

If a dynamic value V has type T, 

How to distinguish between virtual and physical addresses??
How to define these things???

Note that when passing static data through functions, "Physical Address"'s
can be passed to save stack memory and allow for externally mutating functions. 

If a static value V has type T,
it's address when passed through a function will have type phy<T>.

A type is dynamic iff its corresponding values must reside in 
the garbage collected space.

Thus, a type is dynamic iff one or more of the following properties applies:
*       The type is a virtual address mapping to a value of any type.
*       The type is an array whose internal type is dynamic.
*       The type is a record which contains at least one field with a dynamic type.




:: Assembly Grammar ::

<ID>        ::= [a-zA-Z_][a-zA-Z_0-9]*

<IntConst>      ::= [1-9][0-9]*     // Will be parsed as 64-bit.
<HexConst>      ::= 0x[A-Fa-f0-9]+  
<BitConst>      ::= 0b[01]+
<FltConst>      ::= [0-9]+(\.[0-9]+)?f
<ChrConst>      ::= '.'

<IntegralConst> ::= <IntConst> | <HexConst> | <BitConst> | <ChrConst>

<PrimType>  ::= int | flt | idx | chr


<StaticArr> ::= arr\<<StaticType>, <IntConst>\>

<StaticField>   ::= <StaticType> <ID>;
<StaticRec>     ::= rec \{ <StaticField>+ \}

<StaticType>    ::= <PrimType> | <StaticArr> | <StaticRec>

// A static refernce references something on the stack.
// It ONLY EXISTS in two instances.
// As an argument to a function. Or as the consequence of 
// aquiring the lock on a Dynamic Reference.
// Any other usage allows for unsafe operations!
<StaticRef> ::= phy\<<StaticType>\>         

// A "vec" is a variable but fixed size array.
<DynamicVec>    ::= vrt\<vec\<<Type>\>\>
<DynamicArr>    ::= vrt\<arr\<<DynamicType>, <IntConst>\>\>
<DynamicRef>    ::= vrt\<<Type>\>

<DynamicField>  ::= <DynamicType> <ID>;
<DynamicRec>    ::= rec \{ <DynamicField>+ <StaticField>* \}

<DynamicType>   ::=

<Type>          ::= <StaticType> | <DynamicType>


<TypeDef>













