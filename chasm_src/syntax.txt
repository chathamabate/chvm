
:: SYNTAX NOTES FOR CHVM ASSEMBLY ::

:: Typing ::

There are 4 primitive types :
- int   A signed 64-bit integer.
- flt   A 64-bit floating point number.
- idx   A 32-bit unsigned integer. (Used for offsets into arrays)
- chr   A 8-bit character/byte.

All remaining types are built from these types.

An array or "arr" is a composite value containing a fixed length sequence of
identically typed values.

Examples :
arr<int, 5>             An array of 5 integers.
arr<arr<flt, 3>, 3>     A 3x3 matrix of floats.

A record or "rec" is a value composed of named values.
The types of these values can be heterogeneous.

Examples :

rec {
    int x;
    int y;
}

rec {
    arr<char, 6> id;

    rec {
        int x;
        int y;
    } coordinate;
}

From this point further, a piece of data managed by the garbage collector
will be known as "Dynamic" whereas a piece of data which resides on the 
call stack will be known as "Static". 

Now we will define reference types. These types will be used to reference
values. There will be two types of references. Physical Addresses, and
Virtual Addresses.

A Physical Address is a C pointer. (64-bit) It can be used to access
a static or dynamic piece of data.

A physical address is denoted with the * character.

Ex:
*int            The physical address of an integer.
*arr<int, 3>    The physical address of an array of 3 integers.

A Virtual Address can be used to acquire the physical address of a piece of
dynamic data. (128-bit)

A virtual addressis denoted with the @ character.

Ex:
@int                    The virtual address of a dynamic integer.
@rec { int x; int y; }  The virtual address of a dynamic coordinate.

If an identifier O has type @T, then acquiring O's lock will give a 
value of type *T.

Notes On Physical Addresses:


Notes On Arrays and Array Typing:
An array is a value. To pass the value of an array to a function, the function
must know the exact length of the array to be able to set aside the
correct amount of space on the stack.

However, arrays are often used with variable lengths. That is maybe an 
array's length (and thus size) is unknown until runtime.
To account for this there is the ? character.

Ex:
arr<int, ?>         Is the value of an array with variable length.
                    (This value alone CANNOT be passed to a function)

arr<int, 3>         Is the value of an array with a fixed length of 3.
                    NOTE: a value of this type also technically has type
                    arr<int, ?>.

*arr<int, ?>        Is the physical address of an array with a variable 
                    length.

*arr<int, 3>        Is the physical address of an array with a fixed length
                    of the 3. NOTE: a value with this type also has type
                    *arr<int, ?>.




:: Assembly Grammar ::

<ID>        ::= [a-zA-Z_][a-zA-Z_0-9]*

<IntConst>      ::= [1-9][0-9]*     // Will be parsed as 64-bit.
<HexConst>      ::= 0x[A-Fa-f0-9]+  
<BitConst>      ::= 0b[01]+
<FltConst>      ::= [0-9]+(\.[0-9]+)?f
<ChrConst>      ::= '.'

<IntegralConst> ::= <IntConst> | <HexConst> | <BitConst> | <ChrConst>

<PrimType>  ::= int | flt | idx | chr


<StaticArr> ::= arr\<<StaticType>, <IntConst>\>

<StaticField>   ::= <StaticType> <ID>;
<StaticRec>     ::= rec \{ <StaticField>+ \}

<StaticType>    ::= <PrimType> | <StaticArr> | <StaticRec>

// A static refernce references something on the stack.
// It ONLY EXISTS in two instances.
// As an argument to a function. Or as the consequence of 
// aquiring the lock on a Dynamic Reference.
// Any other usage allows for unsafe operations!
<StaticRef> ::= phy\<<StaticType>\>         

// A "vec" is a variable but fixed size array.
<DynamicVec>    ::= vrt\<vec\<<Type>\>\>
<DynamicArr>    ::= vrt\<arr\<<DynamicType>, <IntConst>\>\>
<DynamicRef>    ::= vrt\<<Type>\>

<DynamicField>  ::= <DynamicType> <ID>;
<DynamicRec>    ::= rec \{ <DynamicField>+ <StaticField>* \}

<DynamicType>   ::=

<Type>          ::= <StaticType> | <DynamicType>


<TypeDef>













