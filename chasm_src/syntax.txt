
:: SYNTAX NOTES FOR CHVM ASSEMBLY ::

:: Typing ::

There are 4 primitive types :
- int   A signed 64-bit integer.
- flt   A 64-bit floating point number.
- idx   A 32-bit unsigned integer. (Used for offsets into arrays)
- chr   A 8-bit character/byte.

All remaining types are built from these types.

An array or "arr" is a composite value containing a fixed length sequence of
identically typed values.

Examples :
arr<int, 5>             An array of 5 integers.
arr<arr<flt, 3>, 3>     A 3x3 matrix of floats.

A record or "rec" is a value composed of named values.
The types of these values can be heterogeneous.

Examples :

rec {
    int x;
    int y;
}

rec {
    arr<char, 6> id;

    rec {
        int x;
        int y;
    } coordinate;
}

From this point further, a piece of data managed by the garbage collector
will be known as "Dynamic" whereas a piece of data which resides on the 
call stack will be known as "Static". 

Data in general will be referenced in the assembly code through the use
text identifiers. Ex. num, user_email, or student1.

The mechanisms of these identifiers will differ depending on whether
the identifier is in reference to a dynamic or static piece of data.

If an identifier resolves to a static piece of data, said data can 
be accessed and mutated directly as the identifiers type can be thought
of as identical to the type of the data it references.

If an identifier resolves to a dynamic piece of data, things are different.
In this case, the id resolves to the "Virtual Address" of the piece of 
data. To retrieve the "Physical Address" of the data, the user must
use an aquire statement.

Example:
// name_list is of type arr<vec<char>, 4>
// name_list holds 4 character vectors (i.e. strings)
// Each vector represents a different name.

aquire read name_list as nl_p;  

// Between these statements, nl_p contains the temporary physical address
// of the name_list array.

release name_list;  // Make sure to release to resume GC.

A type T is dynamic iff a value of type T MUST reside in the garbage collected
space. Thus, a type is dynamic iff one or more of the following properties apply:
*       The type is a virtual address mapping to a value of any type.
*       The type is a vector.
*       The type is an array whose internal type is dynamic.
*       The type is a record which contains at least one field with a dynamic type.

Example:

rec {
    vrt<arr<int, 2>> coord;
    int weight;
}

Above, since coord is a virtual address mapping to an array in the garbage collected
space, the whole record type is dynamic and itself must be on the garbage collected 
space!




:: Assembly Grammar ::

<ID>        ::= [a-zA-Z_][a-zA-Z_0-9]*

<IntConst>      ::= [1-9][0-9]*     // Will be parsed as 64-bit.
<HexConst>      ::= 0x[A-Fa-f0-9]+  
<BitConst>      ::= 0b[01]+
<FltConst>      ::= [0-9]+(\.[0-9]+)?f
<ChrConst>      ::= '.'

<IntegralConst> ::= <IntConst> | <HexConst> | <BitConst> | <ChrConst>

<PrimType>  ::= int | flt | idx | chr


<StaticArr> ::= arr\<<StaticType>, <IntConst>\>

<StaticField>   ::= <StaticType> <ID>;
<StaticRec>     ::= rec \{ <StaticField>+ \}

<StaticType>    ::= <PrimType> | <StaticArr> | <StaticRec>

// A static refernce references something on the stack.
// It ONLY EXISTS in two instances.
// As an argument to a function. Or as the consequence of 
// aquiring the lock on a Dynamic Reference.
// Any other usage allows for unsafe operations!
<StaticRef> ::= phy\<<StaticType>\>         

// A "vec" is a variable but fixed size array.
<DynamicVec>    ::= vrt\<vec\<<Type>\>\>
<DynamicArr>    ::= vrt\<arr\<<DynamicType>, <IntConst>\>\>
<DynamicRef>    ::= vrt\<<Type>\>

<DynamicField>  ::= <DynamicType> <ID>;
<DynamicRec>    ::= rec \{ <DynamicField>+ <StaticField>* \}

<DynamicType>   ::=

<Type>          ::= <StaticType> | <DynamicType>


<TypeDef>













