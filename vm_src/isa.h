#ifndef VM_ISA_H
#define VM_ISA_H

#include <stdint.h>

// The virtual machine be use the following pipeline of
// code translation.
//
//       Assembler   Virtual Machine
//           |            | 
// Assembly ==> Bytecode ==> Program Text
//
// Bytecode can be generated by an assembler or a compiler
// and will include simple type safety and operation restrictions.
//
// When the VM loads the bytecode into memory, it will verify
// its structure and operations and translate it into an
// even more rudementary and unsafe type of code (Program Text).
//
// Since the VM itself will run verfication on the bytecode
// it will be able to confirm correctness of potentially unsafe
// operations which appear in the target program text.
//
// A bytecode file will be all encompassing.
// In theory, the assembler/compiler/linker used will
// translate and combine all source code into a single bytecode file
// to provide to the virtual machine.
//
// That is a bytecode file will contain all information
// necessary to run itself. (Kinda like an exectuable binary)

typedef uint32_t type_id;

// Primitive types.
extern const type_id U8;
extern const type_id I32;
extern const type_id I64;
extern const type_id F64;

// A bytecode file will be broken into sections.
//
// Each section will start with a section code.

typedef uint8_t section_code;

// A type def section will map a type_id to a new type.
extern const section_code TYPE_DEF;




// Simple data types:
//
// u8       Single character/unsigned byte
// i32      32-bit signed integer   (Primary use will be offsets)
// i64      64-bit signed integer
// f64      64-bit floating point number
//
// ptr      128-bit virtual address of an object in the collected
//          space. How will type checkign work here???
//
//


#endif
